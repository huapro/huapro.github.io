---
layout:     post
title:      "Linux系统结构"
subtitle:   "Linux系统结构 详解
date:       2018-03-28  18:16:00
author:     "Hua"
header-img: "img/网络.JPG"
catalog: true
multilingual: false
tags:
- linux
---



Linux系统一般有4个主要部分：

内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。部分层次结构如图1-1所示。


1. linux内核

        内核是操作系统的核心，具有很多最基本功能，它负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。

       Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图：



系统调用接口：SCI 层提供了某些机制执行从用户空间到内核的函数调用。这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。

   1. 内存管理 
        对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。

　    不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。
　　 为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。

    2 .进程管理
       进程实际是某特定应用程序的一个运行实体。在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。
       进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。 
    
        通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。 为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有信号、管道、共享内存、信号量和套接字等。 
    
       内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSⅨ] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。
    
    3. 文件系统 
       和 DOS 等操作系统不同，Linux 操作系统中单独的文件系统并不是由驱动器号或驱动器名称（如 A:  或 C:  等）来标识的。相反，和 UNIX  操作系统一样，Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。Linux  操作系统的一个重要特点是它支持许多不同类型的文件系统。Linux 中最普遍使用的文件系统是 Ext2，它也是 Linux  土生土长的文件系统。但 Linux  也能够支持 FAT、VFAT、FAT32、MINIX 等不同类型的文件系统，从而可以方便地和其它操作系统交换数据。由于 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.
       虚拟文件系统（VirtualFileSystem,VFS）:隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来，为所有的设备提供了统一的接口，VFS提供了多达数十种不同的文件系统。虚拟文件系统可以分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2,fat等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。 


       虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层。即VFS 在用户和文件系统之间提供了一个交换层。


VFS         在用户和文件系统之间提供了一个交换层:


在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。
　　文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。
      因此，用户和进程不需要知道文件所在的文件系统类型，而只需要象使用 Ext2  文件系统中的文件一样使用它们。

     4. 设备驱动程序 
      设备驱动程序是 Linux  内核的主要部分。和操作系统的其它部分类似，设备驱动程序运行在高特权级的处理器环境中，从而可以直接对硬件进行操作，但正因为如此，任何一个设备驱动程序的错误都可能导致操作系统的崩溃。设备驱动程序实际控制操作系统和硬件设备之间的交互。设备驱动程序提供一组操作系统可理解的抽象接口完成和操作系统之间的交互，而与硬件相关的具体操作细节由设备驱动程序完成。一般而言，设备驱动程序和设备
的控制芯片有关，例如，如果计算机硬盘是 SCSI  硬盘，则需要使用 SCSI  驱动程序，而不是 IDE 驱动程序。 
    5.网络接口（NET）   
       提供了对各种网络标准的存取和各种网络硬件的支持。网络接口可分为网络协议和网络驱动程序。网络协议部分负责实现每一种可能的网络传输协议。众所周知，TCP/IP  协议是 Internet  的标准协议，同时也是事实上的工业标准。Linux  的网络实现支持 BSD 套接字，支持全部的TCP/IP协议。Linux内核的网络部分由BSD套接字、网络协议层和网络设备驱动程序组成。 
    网络设备驱动程序负责与硬件设备通讯，每一种可能的硬件设备都有相应的设备驱动程序。




1.     2 . linux shell

shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。
目前主要有下列版本的shell。
1．Bourne Shell：是贝尔实验室开发的。 　
2．BASH：是GNU的Bourne Again Shell，是GNU操作系统上默认的shell,大部分linux的发行套件使用的都是这种shell。
3．Korn Shell：是对Bourne SHell的发展，在大部分内容上与Bourne Shell兼容。 　　　
4．C Shell：是SUN公司Shell的BSD版本。


 3 . linux 文件系统

文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、 EXT3、 FAT、 FAT32、 VFAT和ISO9660。


3.1 文件类型
Linux下面的文件类型主要有：
1) 普通文件：C语言元代码、SHELL脚本、二进制的可执行文件等。分为纯文本和二进制。
2) 目录文件：目录，存储文件的唯一地方。
3) 链接文件：指向同一个文件或目录的的文件。
4) 设备文件：与系统外设相关的，通常在/dev下面。分为块设备和字符设备。

5）管道(FIFO)文件 :  提供进程建通信的一种方式
6）套接字(socket) 文件： 该文件类型与网络通信有关

可以通过ls –l, file, stat几个命令来查看文件的类型等相关信息。


3.2  Linux目录 
　　文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。
　　目录提供了管理文件的一个方便而有效的途径。
　　Linux使用标准的目录结构，在安装的时候，安装程序就已经为用户创建了文件系统和完整而固定的目录组成形式，并指定了每个目录的作用和其中的文件类型。

      完整的目录树可划分为小的部分，这些小部分又可以单独存放在自己的磁盘或分区上。这样，相对稳定的部分和经常变化的部分可单独存放在不同的分区中，从而方便备份或系统管理。目录树的主要部分有 root、/usr、/var、/home  等（图2） 。这样的布局可方便在 Linux 计算机之间共享文件系统的某些部分。 



Linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。

      微软的DOS和windows也是采用树型结构，但是在DOS和 windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。最顶部的是不同的磁盘（分区），如：C，D，E，F等。

      但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。

3.3 Linux磁盘分区

   一、主分区，扩展分区和逻辑分区：　　 

linux分区不同于windows,硬盘和硬盘分区在Linux都表示为设备.

硬盘分区一共有三种：主分区，扩展分区和逻辑分区。　　 

硬盘的分区主要分为主分区(Primary Partion)和扩展分区(Extension Partion)两种，主分区和扩展分区的数目之和不能大于四个。

主分区(Primary Partion)：可以马上被使用但不能再分区。

扩展分区(Extension Partion)：必须再进行分区后才能使用，也就是说它必须还要进行二次分区。

逻辑分区（(Logical Partion)）：由扩展分区建立起来的分区。逻辑分区没有数量上限制。

扩展分区只不过是逻辑分区的“容器”，实际上只有主分区和逻辑分区进行数据存储。 

   二、Linux下硬盘分区的标识
硬盘分区的标识一般使用/dev/hd[a-z]X或者/dev/sd[a-z]X来标识，其中[a-z]代表硬盘号，X代表硬盘内的分区号。

整块硬盘分区的块号标识:Linux下用hda、hdb、sda、sdb 等来标识不同的硬盘;

其中：

IDE接口硬盘：表示为/dev/hda1、/dev/hdb ...；

SCSI 接口的硬盘、SATA接口的硬盘表示为/dev/sda、/dev/sdb ... ... ；

硬盘内的分区：如果X的值是1到4,表示硬盘的主分区（包含扩展分区）；逻辑分区从是从5开始的，比如/dev/hda5肯定是逻辑分区了；

例如：

用hda1、hda2、 hda5、hda6 来标识不同的分区。其中，字母a 代表第一块硬盘，b代表第二块硬盘，依次类推。而数字1 代表一块硬盘的第一个分区、2 代表第二个分区，依次类推。1 到4 对应的是主分区(Primary Partition)或扩展分区(Extension Partition)。从5开始，对应的都是硬盘的逻辑分区(Logical Partition)。一块硬盘即使只有一个主分区，逻辑分区也是从5开始编号的，这点应特别注意。

总结：一个硬盘分区首先要大确认在哪个硬盘，然后再确认它所在硬盘内的哪个分区。

　　对于/dev/hda 类似的表示方法，也并不寞生吧；我们在Linux通过fdisk -l 就可以查到硬盘是/dev/hda还是/dev/hdb；

　　[root@localhost ~]# fdisk -l

　　Disk /dev/hda: 80.0 GB, 80026361856 bytes

　　255 heads, 63 sectors/track, 9729 cylinders

　　Units = cylinders of 16065 * 512 = 8225280 bytes

　　 Device Boot Start End Blocks Id System

　　/dev/hda1 * 1 970 7791493+ 7 HPFS/NTFS

　　/dev/hda2 971 9729 70356667+ 5 Extended

　　/dev/hda5 971 2915 15623181 b W95 FAT32

　　/dev/hda6 2916 4131 9767488+ 83 linux

　　/dev/hda7 4132 5590 11719386 83 linux

　　/dev/hda8 5591 6806 9767488+ 83 linux

　　/dev/hda9 6807 9657 22900626 83 linux

　　/dev/hda10 9658 9729 578308+ 82 linux swap / Solaris

 请注意第一行， Disk /dev/hda: 80.0 GB, 80026361856 bytes ，这个就是表示机器中只有一个硬盘设备/dev/hda ，体积大小为 80.0G；下面的就是硬盘的分区，每个分区都有详细的信息，在这里不详细说了；

Linux下磁盘分区和目录的关系如下：
– 任何一个分区都必须挂载到某个目录上。

– 目录是逻辑上的区分。分区是物理上的区分。

– 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。

– 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。

3.4 linux主要目录的功用。
　　/bin 二进制可执行命令
　　/dev 设备特殊文件
　　/etc 系统管理和配置文件
　　/etc/rc.d 启动的配置文件和脚本
　　/home 用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
　　/lib 标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件
　　/sbin 系统管理命令，这里存放的是系统管理员使用的管理程序
　　/tmp 公用的临时文件存储点
　　/root 系统管理员的主目录（呵呵，特权阶级）
　　/mnt 系统提供这个目录是让用户临时挂载其他的文件系统。
　　/lost+found 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里
　　/proc 虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。
　　/var 某些大文件的溢出区，比方说各种服务的日志文件
　　/usr 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：
　　      /usr/X11R6 存放X window的目录
　　      /usr/bin 众多的应用程序
　　      /usr/sbin 超级用户的一些管理程序
　　      /usr/doc linux文档
　　      /usr/include linux下开发和编译应用程序所需要的头文件
　　      /usr/lib 常用的动态链接库和软件包的配置文件
　　      /usr/man 帮助文档
　　      /usr/src 源代码，linux内核的源代码就放在/usr/src/linux里
　　      /usr/local/bin 本地增加的命令
　　      /usr/local/lib 本地增加的库
3.5  linux文件系统
　　文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。

1.文件系统类型：
    ext2 ： 早期linux中常用的文件系统
    ext3 ： ext2的升级版，带日志功能
    RAMFS ： 内存文件系统，速度很快
    NFS ： 网络文件系统，由SUN发明，主要用于远程文件共享
    MS-DOS ： MS-DOS文件系统
    VFAT ： Windows 95/98 操作系统采用的文件系统
    FAT ： Windows XP 操作系统采用的文件系统
    NTFS： Windows NT/XP 操作系统采用的文件系统
    HPFS ： OS/2 操作系统采用的文件系统
    PROC : 虚拟的进程文件系统
    ISO9660 ： 大部分光盘所采用的文件系统
    ufsSun : OS 所采用的文件系统
    NCPFS ： Novell 服务器所采用的文件系统
    SMBFS ： Samba 的共享文件系统
    XFS ： 由SGI开发的先进的日志文件系统，支持超大容量文件
    JFS ：IBM的AIX使用的日志文件系统
    ReiserFS : 基于平衡树结构的文件系统
    udf: 可擦写的数据光盘文件系统


2.文件系统特性：

    磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个分区。 格式化的目的是能使操作系统可以使用的文件系统格式（即我们上面提到文件系统类型）. 

        每种操作系统能够使用的文件系统并不相同. 如windows 98 以前的微软操作系统主要利用的文件系统是 FAT (或 FAT16)，windows 2000 以后的版本有所谓的 NTFS 文件系统，至于 Linux 的正统文件系统则为 Ext2 (Linux second extended file system, ext2fs)这一个。此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。

      传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的LVM与软件磁盘阵列(software raid)， 这些技术可以将一个分区格式化为多个文件系统(例如LVM)，也能够将多个分区合成一个文件系统(LVM, RAID)！ 所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区喔！

    那么文件系统是如何运行的呢？这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性，例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中。 另外，还有一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。


      对于一个磁盘分区来说，在被指定为相应的文件系统后，整个分区被分为 1024，2048 和 4096 字节大小的块。根据块使用的不同，可分为：

超级块(Superblock): 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息。
inode块(文件索引节点) : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息. 在 Linux 下可以通过 "ls -li" 命令查看文件的 inode 信息。硬连接和源文件具有相同的 inode 。
数据块(Block) :实际记录文件的内容，若文件太大时，会占用多个 block。为了提高目录访问效率，Linux 还提供了表达路径与 inode 对应关系的 dentry 结构。它描述了路径信息并连接到节点 inode，它包括各种目录信息，还指向了 inode 和超级块。
        就像一本书有封面、目录和正文一样。在文件系统中，超级块就相当于封面，从封面可以得知这本书的基本信息； inode 块相当于目录，从目录可以得知各章节内容的位置；而数据块则相当于书的正文，记录着具体内容。
         Linux正统的文件系统(如ext2、3等)将硬盘分区时会划分出超级块、inode Table区块和data block数据区域。一个文件由一个超级块、inode和数据区域块组成。Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据。


  我们将 inode 与 block 区块用图解来说明一下，如下图所示，文件系统先格式化出 inode 与 block 的区块，假设某一个文件的属性与权限数据是放置到 inode 4 号(下图较小方格内)，而这个 inode 记录了文件数据的实际放置点为 2, 7, 13, 15 这四个 block 号码，此时我们的操作系统就能够据此来排列磁盘的阅读顺序，可以一口气将四个 block 内容读出来！ 那么数据的读取就如同下图中的箭头所指定的模样了。



这种数据存取的方法我们称为索引式文件系统(indexed allocation)。那有没有其他的惯用文件系统可以比较一下啊？ 有的，那就是我们惯用的闪盘(闪存)，闪盘使用的文件系统一般为 FAT 格式。FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中， 其读取方式有点像下图所示:




上图中我们假设文件的数据依序写入1->7->4->15号这四个 block 号码中， 但这个文件系统没有办法一口气就知道四个 block 的号码，他得要一个一个的将 block 读出后，才会知道下一个 block 在何处。 如果同一个文件数据写入的 block 分散的太过厉害时，则我们的磁盘读取头将无法在磁盘转一圈就读到所有的数据， 因此磁盘就会多转好几圈才能完整的读取到这个文件的内容！

    常常会听到所谓的“碎片整理”吧？ 需要碎片整理的原因就是文件写入的 block 太过于离散了，此时文件读取的效能将会变的很差所致。 这个时候可以透过碎片整理将同一个文件所属的 blocks 汇整在一起，这样数据的读取会比较容易啊！ 想当然尔，FAT 的文件系统需要经常的碎片整理一下，那么 Ext2 是否需要磁盘重整呢？

    由于 Ext2 是索引式文件系统，基本上不太需要常常进行碎片整理的。但是如果文件系统使用太久， 常常删除/编辑/新增文件时，那么还是可能会造成文件数据太过于离散的问题，此时或许会需要进行重整一下的。 不过，老实说，鸟哥倒是没有在 Linux 操作系统上面进行过 Ext2/Ext3 文件系统的碎片整理说！似乎不太需要啦！^_^

　　可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：
　　硬连接：原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；
　　由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。
　　符号连接：用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。
　　可以删除原有的文件而保存连接文件，没有防止误删除功能。
　　这一段的的内容过于抽象，又是节点又是数组的，我已经尽量通俗再通俗了，又不好加例子作演示。大家如果还是云里雾里的话，我也没有什么办法了，只有先记住，日后在实际应用中慢慢体会、理解了。这也是我学习的一个方法吧。 

   

3.6 文件系统在内核中的表示

内核数据结构

Linux内核的VFS子系统可以图示如下



文件与IO: 每个进程在PCB（Process Control Block）中都保存着一份文件描述符表，文件描述符就是这个表的索引，每个表项都有一个指向已打开文件的指针，现在我们明确一下：已打开的文件在内核中用file结构体表示，文件描述符表中的指针指向file结构体。

 

在file结构体中维护File Status Flag（file结构体的成员f_flags）和当前读写位置（file结构体的成员f_pos）。在上图中，进程1和进程2都打开同一文件，但是对应不同的file结构体，因此可以有不同的File Status Flag和读写位置。file结构体中比较重要的成员还有f_count，表示引用计数（Reference Count），后面我们会讲到，dup、fork等系统调用会导致多个文件描述符指向同一个file结构体，例如有fd1和fd2都引用同一个file结构体，那么它的引用计数就是2，当close(fd1)时并不会释放file结构体，而只是把引用计数减到1，如果再close(fd2)，引用计数就会减到0同时释放file结构体，这才真的关闭了文件。

 

每个file结构体都指向一个file_operations结构体，这个结构体的成员都是函数指针，指向实现各种文件操作的内核函数。比如在用户程序中read一个文件描述符，read通过系统调用进入内核，然后找到这个文件描述符所指向的file结构体，找到file结构体所指向的file_operations结构体，调用它的read成员所指向的内核函数以完成用户请求。在用户程序中调用lseek、read、write、ioctl、open等函数，最终都由内核调用file_operations的各成员所指向的内核函数完成用户请求。file_operations结构体中的release成员用于完成用户程序的close请求，之所以叫release而不叫close是因为它不一定真的关闭文件，而是减少引用计数，只有引用计数减到0才关闭文件。对于同一个文件系统上打开的常规文件来说，read、write等文件操作的步骤和方法应该是一样的，调用的函数应该是相同的，所以图中的三个打开文件的file结构体指向同一个file_operations结构体。如果打开一个字符设备文件，那么它的read、write操作肯定和常规文件不一样，不是读写磁盘的数据块而是读写硬件设备，所以file结构体应该指向不同的file_operations结构体，其中的各种文件操作函数由该设备的驱动程序实现。

 

每个file结构体都有一个指向dentry结构体的指针，“dentry”是directory entry（目录项）的缩写。我们传给open、stat等函数的参数的是一个路径，例如/home/akaedu/a，需要根据路径找到文件的inode。为了减少读盘次数，内核缓存了目录的树状结构，称为dentry cache，其中每个节点是一个dentry结构体，只要沿着路径各部分的dentry搜索即可，从根目录/找到home目录，然后找到akaedu目录，然后找到文件a。dentry cache只保存最近访问过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。

 

每个dentry结构体都有一个指针指向inode结构体。inode结构体保存着从磁盘inode读上来的信息。在上图的例子中，有两个dentry，分别表示/home/akaedu/a和/home/akaedu/b，它们都指向同一个inode，说明这两个文件互为硬链接。inode结构体中保存着从磁盘分区的inode读上来信息，例如所有者、文件大小、文件类型和权限位等。每个inode结构体都有一个指向inode_operations结构体的指针，后者也是一组函数指针指向一些完成文件目录操作的内核函数。和file_operations不同，inode_operations所指向的不是针对某一个文件进行操作的函数，而是影响文件和目录布局的函数，例如添加删除文件和目录、跟踪符号链接等等，属于同一文件系统的各inode结构体可以指向同一个inode_operations结构体。

 

inode结构体有一个指向super_block结构体的指针。super_block结构体保存着从磁盘分区的超级块读上来的信息，例如文件系统类型、块大小等。super_block结构体的s_root成员是一个指向dentry的指针，表示这个文件系统的根目录被mount到哪里，在上图的例子中这个分区被mount到/home目录下。

 

file、dentry、inode、super_block这几个结构体组成了VFS的核心概念。对于ext2文件系统来说，在磁盘存储布局上也有inode和超级块的概念，所以很容易和VFS中的概念建立对应关系。而另外一些文件系统格式来自非UNIX系统（例如Windows的FAT32、NTFS），可能没有inode或超级块这样的概念，但为了能mount到Linux系统，也只好在驱动程序中硬凑一下，在Linux下看FAT32和NTFS分区会发现权限位是错的，所有文件都是rwxrwxrwx，因为它们本来就没有inode和权限位的概念，这是硬凑出来的。


3.6  挂载文件系统
　　linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。这里所说的“按一定方式”就是指的挂载。
     将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载。把该子目录称为挂载点.

   例如要读取硬盘中的一个格式化好的分区、光盘或软件等设备时，必须先把这些设备对应到某个目录上，而这个目录就称为“挂载点（mount point）”，这样才可以读取这些设备。 挂载后将物理分区细节屏蔽掉，用户只有统一的逻辑概念。所有的东西都是文件。

注意：1、挂载点必须是一个目录。
　　   2、一个分区挂载在一个已存在的目录上，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用。
       对于其他操作系统建立的文件系统的挂载也是这样。但是需要理解的是：光盘、软盘、其他操作系统使用的文件系统的格式与linux使用的文件系统格式是不一样的。光盘是ISO9660；软盘是fat16或ext2；windows NT是fat16、NTFS；windows98是fat16、fat32；windows2000和windowsXP是fat16、fat32、 NTFS。挂载前要了解linux是否支持所要挂载的文件系统格式。
　　挂载时使用mount命令，其格式：mount [-参数] [设备名称] [挂载点]
　　其中常用的参数有
　　-t 指定设备的文件系统类型（什么提到的文件类型）
　　-o 指定挂载文件系统时的选项。有些也可用在/etc/fstab中。常用的有
　　codepage=XXX 代码页
　　iocharset=XXX 字符集
　　ro 以只读方式挂载
　　rw 以读写方式挂载
　　nouser 使一般用户无法挂载
　　user 可以让一般用户挂载设备

例如：

1. 挂载windows的文件系统：
1）首先我们使用sudo fdisk -l查看挂载的设备，例如最下面有：/dev/hda5 
2）mkdir创建一个目录，这里的目录是作为挂在目录，就是你要把E盘挂到这个目录下：mk /mnt/winc
3）windows和linux使用的不是一个文件系统，一般情况下linux不挂载windows文件系统，所以要你手动mount：
    # mount -t vfat /dev/hda5 /mnt/winc  （ -t vfat指出这里的文件系统fat32）
    现在就可以进入/mnt/winc等目录读写这些文件了。
 2.挂载光盘：# mk /mnt/cdrom
          # mount -t iso9660 /dev/cdrom /mnt/cdrom (关盘的名字一般都是cdrom，这条命令一般都通用)
3.虚拟机共享文件夹：例如在VirtualBox下，主机是Windows，Ubuntu是Guest。共分三步：
      1). 首先要安装虚拟电脑工具包：在VirtualBox的菜单里选择"设备"->"安装虚拟电脑工具包"，你会发现在Ubuntu桌面上多出一个光盘图标，这张光盘默认被自动加载到了文件夹/media/cdom0，而且/cdrom自动指向这个文件夹。默认设置下文件管理器会自动打开这张光盘，可以看到里面有个"VBoxLinuxAdditions.run"文件。打开一个命令行终端，依次输入"cd /cdrom"和"sudo sh ./VBoxLinuxAdditions.run"，不含双引号，开始安装工具包。安装完毕，会用英文提示要重启Ubuntu，建议立刻重启。重启后，比较明显的变化是鼠标是共享模式，并且剪贴板也和Windows共享了。如果有这些变化，说明虚拟电脑工具包已经装成功。
      2). 下一步设置共享文件夹。
     在共享文件夹设置窗口中，单击右侧的"添加一个共享文件夹"，路径选择你想要共享的Windows文件夹，共享名任取一个自己喜欢的，比如"myshare"，选项read-only是指是否只允许ubuntu读这个文件夹，请根据需要选择这个选项。
      3). 在ubuntu下挂载这个共享文件夹:sudo mount -t vboxsf myshare /media/share
      其中"myshare"是之前取的共享文件夹的名字，"/media/share"是要挂载到的目标文件.

3.7  自动挂载windows分区
　　每次开机访问windows分区都要运行mount命令显然太烦琐，为什么访问其他的linux分区不用使用mount命令呢？
　　其实，每次开机时，linux自动将需要挂载的linux分区挂载上了。那么我们是不是可以设定让linux在启动的时候也挂载我们希望挂载的分区，如windows分区，以实现文件系统的自动挂载呢？
　　这是完全可以的。在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。我的/etc/fstab文件如下：
　　/dev/hda2 / ext3 defaults 1 1
　　/dev/hda1 /boot ext3 defaults 1 2
　　none /dev/pts devpts gid=5,mode=620 0 0
　　none /proc proc defaults 0 0
　　none /dev/shm tmpfs defaults 0 0
　　/dev/hda3 swap swap defaults 0 0
　　/dev/cdrom /mnt/cdrom iso9660 noauto,codepage=936,iocharset=gb2312 0 0
　　/dev/fd0 /mnt/floppy auto noauto,owner,kudzu 0 0
　　/dev/hdb1 /mnt/winc vfat defaults,codepage=936,iocharset=cp936 0 0
　　/dev/hda5 /mnt/wind vfat defaults,codepage=936,iocharset=cp936 0 0
　　在/etc/fstab文件里，第一列是挂载的文件系统的设备名，第二列是挂载点，第三列是挂载的文件系统类型，第四列是挂载的选项，选项间用逗号分隔。第五六列不知道是什么意思，还望高手指点。
　　在最后两行是我手工添加的windows下的C；D盘，加了codepage=936和iocharset=cp936参数以支持中文文件名。参数defaults实际上包含了一组默认参数：
　　rw 以可读写模式挂载
　　suid 开启用户ID和群组ID设置位
　　dev 可解读文件系统上的字符或区块设备
　　exec 可执行二进制文件
　　auto 自动挂载
　　nouser 使一般用户无法挂载
　　async 以非同步方式执行文件系统的输入输出操作
　　大家可以看到在这个列表里，光驱和软驱是不自动挂载的，参数设置为noauto。（如果你非要设成自动挂载，你要确保每次开机时你的光驱和软驱里都要有盘，呵呵。)
3.8 .软连接、硬链接
　   可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：
　　硬连接：是给文件一个副本，原文件名和连接文件名都指向相同的物理地址。目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）文件在磁盘中只有一个拷贝，节省硬盘空间；

          修改其中一个，与其连接的文件同时被修改。如果删除其中任意一个其余的文件将不受影响。
　　由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。
　　符号连接（软连接）：用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。
　　当然删除这个连接，也不会影响到源文件，但对连接文件的使用、引用都是直接调用源文件的。

      具体关系可以看下图：





 从图上可以看出硬链接和软链接的区别：

1：硬链接原文件和新文件的inode编号一致。而软链接不一样。

2：对原文件删除，会导致软链接不可用，而硬链接不受影响。

3：对原文件的修改，软、硬链接文件内容也一样的修改，因为都是指向同一个文件内容的。

3.9.文件目录管理命令
磁盘和文件空间 ：fdisk df du

文件目录与管理： cd pwd mkdir rmdir ls cp rm mv

查看文件内容 cat、tac、more、less、head 、tail

文件目录与权限 ：chmod chown chgrp umask

文件查找：which、whereis、locate、find、find 



 3 . 4. linux 应用

标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、X Window、办公套件、Internet工具和数据库等。


. 4. 5. linux内核参数优化

内核参数是用户和系统内核之间交互的一个接口，通过这个接口，用户可以在系统运行的同时动态更新内核配置，而这些内核参数是通过Linux Proc文件系统存在的。因此，可以通过调整Proc文件系统达到优化Linux性能的目的。


# Linux 常用命令
 

杀死服务:
```
ps -ef | grep "resources-manager-server" | grep -v grep | cut -c 9-15 | xargs kill -s 9
```
检查服务:
```
ps -ef | grep "resources-manager-server"
```
查找  
(1)find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。   
(2)grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。

###  find命令
```
　　　　基本格式：find  path expression

　　　　1.按照文件名查找

　　　　(1)find / -name httpd.conf　　#在根目录下查找文件httpd.conf，表示在整个硬盘查找
　　　　(2)find /etc -name httpd.conf　　#在/etc目录下文件httpd.conf
　　　　(3)find /etc -name '*srm*'　　#使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件
　　　　(4)find . -name 'srm*' 　　#表示当前目录下查找文件名开头是字符串‘srm’的文件

　　　　2.按照文件特征查找 　　　　

　　　　(1)find / -amin -10 　　# 查找在系统中最后10分钟访问的文件(access time)
　　　　(2)find / -atime -2　　 # 查找在系统中最后48小时访问的文件
　　　　(3)find / -empty 　　# 查找在系统中为空的文件或者文件夹
　　　　(4)find / -group cat 　　# 查找在系统中属于 group为cat的文件
　　　　(5)find / -mmin -5 　　# 查找在系统中最后5分钟里修改过的文件(modify time)
　　　　(6)find / -mtime -1 　　#查找在系统中最后24小时里修改过的文件
　　　　(7)find / -user fred 　　#查找在系统中属于fred这个用户的文件
　　　　(8)find / -size +10000c　　#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)
　　　　(9)find / -size -1000k 　　#查找出小于1000KB的文件

　　　　3.使用混合查找方式查找文件

　　　　参数有： ！，-and(-a)，-or(-o)。

　　　　(1)find /tmp -size +10000c -and -mtime +2 　　#在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件
   　　    (2)find / -user fred -or -user george 　　#在/目录下查找用户是fred或者george的文件文件
   　　    (3)find /tmp ! -user panda　　#在/tmp目录中查找所有不属于panda用户的文件
    　　  

　　二、grep命令

　　　  基本格式：find  expression

 　　　 1.主要参数

　　　　[options]主要参数：
　　　　－c：只输出匹配行的计数。
　　　　－i：不区分大小写
　　　　－h：查询多文件时不显示文件名。
　　　　－l：查询多文件时只输出包含匹配字符的文件名。
　　　　－n：显示匹配行及行号。
　　　　－s：不显示不存在或无匹配文本的错误信息。
　　　**　－v：显示不包含匹配文本的所有行。**

　　　　pattern正则表达式主要参数：
　　　　\： 忽略正则表达式中特殊字符的原有含义。
　　　　^：匹配正则表达式的开始行。
　　　　$: 匹配正则表达式的结束行。
　　　　\<：从匹配正则表达 式的行开始。
　　　　\>：到匹配正则表达式的行结束。
　　　　[ ]：单个字符，如[A]即A符合要求 。
　　　　[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。
　　　　.：所有的单个字符。
　　　　* ：有字符，长度可以为0。

　　　　2.实例　 

　　(1)grep 'test' d*　　#显示所有以d开头的文件中包含 test的行
　　(2)grep ‘test’ aa bb cc 　　 #显示在aa，bb，cc文件中包含test的行
　　(3)grep ‘[a-z]\{5\}’ aa 　　#显示所有包含每行字符串至少有5个连续小写字符的字符串的行
　　(4)grep magic /usr/src　　#显示/usr/src目录下的文件(不含子目录)包含magic的行
　　(5)grep -r magic /usr/src　　#显示/usr/src目录下的文件(包含子目录)包含magic的行

　　(6)grep -w pattern files ：只匹配整个单词，而不是字符串的一部分(如匹配’magic’，而不是’magical’)
```
## tail
tail -f 实时查看日志文件 tail -f 日志文件log  
tail - 100f 实时查看日志文件 后一百行  
tail -f -n 100 catalina.out linux查看日志后100行  


## 
```
Linux常用shell种类
　　不同的shell具备不同的功能，shell还决定了Linux中默认的shell是/bin/bash，流行的shell有ash、bash、ksh、csh、zsh等，不同的shell都有自己的特点以及用途。

bash
大多数Linux系统默认使用的shell，bash shell是Bourne shell 的一个免费版本，它是最早的Unix shell,bash还有一个特点，可以通过help命令
来查看帮助。包含的功能几乎可以涵盖shell所具有的功能，所以一般的shell脚本都会指定它为执行路径。

csh
C shell 使用的是“类C”语法，csh是具有C语言风格的一种shell，其内部命令有52个，较为庞大。目前使用的并不多，
已经被/bin/tcsh所取代。

ksh
Korn shell 的语法与Bourne shell相同，同时具备了C shell的易用特点。许多安装脚本都使用ksh,ksh 有42条内部命令，与bash相比有一定的限制性。

tcsh
tcsh是csh的增强版，与C shell完全兼容。

sh
是一个快捷方式，已经被/bin/bash所取代。

nologin
指用户不能登录

zsh
目前Linux里最庞大的一种shell：zsh。它有84个内部命令，使用起来也比较复杂。一般情况下，不会使用
该shell。
```
```
/etc目录

　　包含很多文件.许多网络配置文件也在/etc 中. 
/etc/rc   or/etc/rc.d   or/etc/rc*.d  
　　启动、或改变运行级时运行的scripts或scripts的目录. 

/etc/passwd  
　　用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息. 

/etc/fdprm  
　　软盘参数表.说明不同的软盘格式.用setfdprm 设置.

/etc/fstab  
　　启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表.Linux下，也包括用swapon -a启用的swap区的信息.

/etc/group  
　　类似/etc/passwd ，但说明的不是用户而是组. 

/etc/inittab  
　　init 的配置文件. 

/etc/issue  
　　getty在登录提示符前的输出信息.通常包括系统的一段短说明或欢迎信息.内容由系统管理员确定. 

/etc/magic  
　　file 的配置文件.包含不同文件格式的说明，file 基于它猜测文件类型.


/etc/motd  
　　Message Of TheDay，成功登录后自动输出.内容由系统管理员确定.经常用于通告信息，如计划关机时间的警告. 

/etc/mtab  
　　当前安装的文件系统列表.由scripts初始化，并由mount 命令自动更新.需要一个当前安装的文件系统的列表时使用，例如df命令. 

/etc/shadow  
　　在安装了影子口令软件的系统上的影子口令文件.影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow中，而后者只对root可读.这使破译口令更困难. 

/etc/login.defs  
　　login 命令的配置文件. 

/etc/printcap  
　　类似/etc/termcap ，但针对打印机.语法不同. 

/etc/profile , /etc/csh.login ,/etc/csh.cshrc  
　　登录或启动时Bourne或Cshells执行的文件.这允许系统管理员为所有用户建立全局缺省环境. 

/etc/securetty  
　　确认安全终端，即哪个终端允许root登录.一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权. 

/etc/shells  
　　列出可信任的shell.chsh 命令允许用户在本文件指定范围内改变登录shell.提供一台机器FTP服务的服务进程ftpd检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录. 

/etc/termcap 

```
```
Linux定时任务Crontab命令详解
linux 系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另 外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。

一、crond简介

crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务 工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。

Linux下的任务调度分为两类，系统任务调度和用户任务调度。

系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。

/etc/crontab文件包括下面几行：

cat /etc/crontab

SHELL=/bin/bash

PATH=/sbin:/bin:/usr/sbin:/usr/bin

MAILTO=HOME=/

# run-parts

51 * * * * root run-parts /etc/cron.hourly

24 7 * * * root run-parts /etc/cron.daily

22 4 * * 0 root run-parts /etc/cron.weekly

42 4 1 * * root run-parts /etc/cron.monthly


前 四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行 命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。

用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。

使用者权限文件：

文件：

/etc/cron.deny

说明：

该文件中所列用户不允许使用crontab命令

文件：

/etc/cron.allow

说明：

该文件中所列用户允许使用crontab命令

文件：

/var/spool/cron/

说明：

所有用户crontab文件存放的目录,以用户名命名

crontab文件的含义：

用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：

minute hour day month week command

其中：

minute： 表示分钟，可以是从0到59之间的任何整数。

hour：表示小时，可以是从0到23之间的任何整数。

day：表示日期，可以是从1到31之间的任何整数。

month：表示月份，可以是从1到12之间的任何整数。

week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。

command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。



在以上各个字段中，还可以使用以下特殊字符：

星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。

逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”

中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”

正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。

二、crond服务

安装crontab：

yum install crontabs

服务操作说明：

/sbin/service crond start //启动服务

/sbin/service crond stop //关闭服务

/sbin/service crond restart //重启服务

/sbin/service crond reload //重新载入配置

/sbin/service crond status //启动服务


查看crontab服务是否已设置为开机启动，执行命令：

ntsysv

加入开机自动启动：

chkconfig –level 35 crond on

三、crontab命令详解

1．命令格式：

crontab [-u user] file

crontab [-u user] [ -e | -l | -r ]

2．命令功能：

通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。

3．命令参数：

-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。

file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。

-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。

-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。

-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。

-i：在删除用户的crontab文件时给确认提示。

4．常用方法：

1). 创建一个新的crontab文件

在 考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑 crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其 中加入这样一行：

EDITOR=vi; export EDITOR

然后保存并退出。不妨创建一个名为<user> cron的文件，其中<user>是用户名，例如， davecron。在该文件中加入如下的内容。

# (put your own initials here)echo the date to the console every

# 15minutes between 6pm and 6am

0,15,30,45 18-06 * * * /bin/echo ‘date’ > /dev/console

保存并退出。确信前面5个域用空格分隔。

在 上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些 系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为 cron命令的参数：

$ crontab davecron

现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。

同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。

2). 列出crontab文件

为了列出crontab文件，可以用：

$ crontab -l

0,15,30,45,18-06 * * * /bin/echo `date` > dev/tty1

你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份：

$ crontab -l > $HOME/mycron

这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。

3). 编辑crontab文件

如果希望添加、删除或编辑crontab文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑crontab文件，相应的命令为：

$ crontab -e

可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。

我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：

# DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month

30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm {} \;

现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。

现在让我们使用前面讲过的crontab -l命令列出它的全部信息：

$ crontab -l

# (crondave installed on Tue May 4 13:07:43 1999)

# DT:ech the date to the console every 30 minites

0,15,30,45 18-06 * * * /bin/echo `date` > /dev/tty1

# DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month

30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm {} \;

4). 删除crontab文件

要删除crontab文件，可以用：

$ crontab -r

5). 恢复丢失的crontab文件

如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：

$ crontab <filename>

其中，<filename>是你在$ H O M E目录中副本的文件名。

我建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。

有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<Ctrl-D>，否则你将丢失crontab文件。

5．使用实例

实例1：每1分钟执行一次command
命令：
* * * * * command
实例2：每小时的第3和第15分钟执行
命令：
3,15 * * * * command
实例3：在上午8点到11点的第3和第15分钟执行
命令：
3,15 8-11 * * * command
实例4：每隔两天的上午8点到11点的第3和第15分钟执行
命令：
3,15 8-11 */2 * * command
实例5：每个星期一的上午8点到11点的第3和第15分钟执行
命令：
3,15 8-11 * * 1 command
实例6：每晚的21:30重启smb 
命令：
30 21 * * * /etc/init.d/smb restart


实例7：每月1、10、22日的4 : 45重启smb 
命令：
45 4 1,10,22 * * /etc/init.d/smb restart


实例8：每周六、周日的1 : 10重启smb
命令：
10 1 * * 6,0 /etc/init.d/smb restart


实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb 
命令：
0,30 18-23 * * * /etc/init.d/smb restart


实例10：每星期六的晚上11 : 00 pm重启smb 
命令：
0 23 * * 6 /etc/init.d/smb restart


实例11：每一小时重启smb 
命令：
* */1 * * * /etc/init.d/smb restart


实例12：晚上11点到早上7点之间，每隔一小时重启smb 
命令：
* 23-7/1 * * * /etc/init.d/smb restart
实例13：每月的4号与每周一到周三的11点重启smb 
命令：
0 11 4 * mon-wed /etc/init.d/smb restart
实例14：一月一号的4点重启smb 
命令：
0 4 1 jan * /etc/init.d/smb restart


实例15：每小时执行/etc/cron.hourly目录内的脚本
命令：
01 * * * * root run-parts /etc/cron.hourly
说明：
run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了


四、使用注意事项

注意环境变量问题
有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。

在 crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程 序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这 样，系统执行任务调度时就没有问题了。

不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：

1）脚本中涉及文件路径时写全局路径；

2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：

cat start_cbp.sh

#!/bin/sh

source /etc/profile

export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf

/usr/local/jboss-4.0.5/bin/run.sh -c mev &

3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：

0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh

注意清理系统用户的邮件日志
每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。

例如，可以在crontab文件中设置如下形式，忽略日志输出：

0 */3 * * * /usr/local/apache2/apachectl restart >/dev/null 2>&1

“/dev/null 2>&1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。

系统级任务调度与用户级任务调度
系 统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么 做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc /crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个 定时重启系统的任务也是无效的。

其他注意事项
新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。

当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。

千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。

在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\%Y\%m\%d’。
```